Some short-term goals
---------------------

1. Introduce an input event abstraction

Currently we just dump SDL events directly into a stream; we should create
an enumeration that gathers together various things we care about putting
into the network, so they can be present in the same stream. E.g.,
    * Keyboard input
    * Mouse movement / clicks
    * Time deltas?

XXX: not sure about including time deltas there; we'd prefer to not use
deltas for anything except generating the timestream.


2. Move editor GUI to a separate module

Create an interface that just exposes the relevant streams and signals;
should allow a fairly elegant decoupling of GUI from the main loop. Probably
depends on #1, or at least having mouse events in carboxyl.


3. Move audio to a separate module, add basic mixing interface

3a. FRP audio mixer

Figure out a nice way to use FRP in the mixer. It would be super cool to
represent every channel as a reactive behavior, but this raises at least two
questions:

    1.  In a push-pull system, what is the "push" that induces the behavior
        to change?

    2.  When sampling from a channel, how does the underlying reactive
        behavior know how many samples to provide?

Both points are related to the necessarily discrete and chunked nature of
audio sampling. Currently an SDL audio callback is invoked at regular
intervals and expected to fill a buffer of a size known at the point where the
audio system is initialized.

Possibly, then, we could "push" a value into the audio network that indicates
how many samples will be required; each behavior (channel) could then produce
an appropraite number of samples from their sources.

NOTE: behaviors would also seem a natural way to implement transformations in
the audio mixer as well; e.g., an upsampling fold or low-pass filter, of
particular relevance to SPC emulator generated samples, as those are currently
fixed at 32KHz.


4. Greenfield a new FRP physics approach. Probably put momentum first.

Our first-order abstraction for physics entities will be a pair of signals,
momentum and position. (We can assume that in this system, σₓσₛ≠ħ/2) In the
normal course of things, position should be straightforwardly derived from
momentum. We'll implement just two momentum functions at first: constant,
and keyboard-controlled.

This should (hopefully) make it a bit easier to implement collision detection
in terms of momentum and position signals.
